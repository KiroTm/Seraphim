import { ButtonInteraction, EmbedBuilder, Guild, GuildMember, Interaction, InteractionReplyOptions, TextChannel } from "discord.js";
import { ConfigHandler } from "../../../../../Main-Handler/ConfigHandler";
import DB from "../../../../Models/tickets-schema";
import TicketSetupData from '../../../../Models/TicketSetup';
import { createTranscript } from "discord-html-transcripts";
function canRun(member: GuildMember, data: any): boolean {
    const handlers = data.Handlers as string[]
    const MemberRoles = member.roles.cache.map((r) => { return r.id })
    const Object = {
        Handlers: handlers,
        Roles: MemberRoles
    }
    return Object.Roles.some(role => Object.Handlers.includes(role));
}
async function editReply(interaction: ButtonInteraction, options: InteractionReplyOptions) { await interaction.editReply(options) }
export default async (instance: ConfigHandler, interaction: Interaction) => {    
    if (!interaction.isButton()) return;    
    if (!["ticket_close_transcript", "ticket_close_reopen", "ticket_close_delete"].includes(interaction.customId)) return;
    const guild = interaction.guild as Guild
    const mem = interaction.member as GuildMember
    const channel = interaction.channel as TextChannel    
    const TicketSetups = await TicketSetupData.findOne({ GuildID: guild?.id })
    await interaction.deferReply({ephemeral: true})      
    if (!TicketSetups) return await editReply(interaction, { content: `Cannot fetch data for this guild, please make sure you have tickets enabled for/in this guild.`, ephemeral: true })
    const docs = await DB.findOne({ GuildID: guild.id, ChannelID: channel.id })
    if (!docs) return editReply(interaction, { content: "<:fail:1146683470114996274> Could not find any data regarding this ticket, please re-initiate a ticket!" })    
    if (canRun(mem, TicketSetups) == false) return await editReply(interaction, { content: `Do not use these fancy buttons just for the sake of clicking. They are intended for a specific purpose and should not be used frivolously.`})
    switch (interaction.customId) {
        case "ticket_close_reopen": {          
            const Members: string[] = docs.MemberID
            Members.forEach(async(m: string) => {                
                await channel.permissionOverwrites.edit(m, {
                    SendMessages: true,
                    ViewChannel: true
                })
            })
            await DB.updateOne({ ChannelID: channel.id }, { Closed: false });
            await interaction.editReply({content: "Opening ticket.."})         
            await interaction.message.edit({
                embeds: [
                    new EmbedBuilder()
                    .setColor('Green')
                    .setDescription(`Ticket reopened by ${mem.user}`)
                ],
                components: []
            })            
        }
        break;

        case "ticket_close_delete": {
            await DB.updateOne({ChannelID: channel.id}, {Closed: false, HasTicket: false})
            await interaction.editReply("ℹ️ Ticket will be deleted shortly!")
            await channel.send({
                embeds: [
                    new EmbedBuilder()
                    .setColor('Green')
                    .setAuthor({
                        name: mem.user.username,
                        iconURL: `${mem.user.displayAvatarURL({forceStatic: false})}`
                    })
                    .setDescription(`ℹ️ This ticket has been put into deletion by ${mem.user.username}`)
                ]
            })
            setTimeout(async () => {
                await channel.delete()
            }, 3000);
        }   
        break;

        case "ticket_close_transcript": {            
            await interaction.editReply("Transcript will be sent soon!")
            let TranscriptChannelID: string = `${channel.id}`;
            if (TicketSetups.Transcripts !== "None") {
                TranscriptChannelID = `${TicketSetups.Transcripts}`
            }
            await channel.send({
                embeds: [
                    new EmbedBuilder()
                    .setColor('Aqua')
                    .setDescription(`ℹ️ Transcript request has been generated by ${mem.user}!`)
                ]
            })
            const Transcript = await createTranscript(channel, {                
                limit: -1,
                poweredBy: true,  
                filename: `ticket.html`,
                saveImages: true                           
            })              
            const TranscriptChannel = (await guild.channels.fetch()).get(`${TranscriptChannelID}`) as TextChannel
            await TranscriptChannel.send({
                files: [
                    Transcript
                ]
            })     
        }
    }
}